# FMTOWNS-ROLL
FM TOWNS Demo - Zoom &amp; Rotate


Oh! FM TOWNS 1994年8月号 連載「Makkenの天下無双！プログラム一本勝負」内に掲載されているHigh Cコンパイラ用「回転処理」(Makken著作)のコードを元に最適化、ダブルバッファ表示によるティアリング防止、回転のみだけでなく拡大縮小と表示位置変更が行えるように改造したもの。最大256*256ドット・32768色・無圧縮TIFF画像を256*240ドット画面に表示して拡大縮小・回転・移動表示が行えます。

1994年9月号の同連載には最適化のためアセンブラ化とこれと同じく拡大縮小処理を加えたコードが掲載されているが、アセンブラで記述するのが面倒だったので何とかC言語コードでできないかとがんばってみた。80386 16MHz相当で1～2fpsだったのが、3fps程度にはなったと思う。

# 使い方
コンソールから「RUN386 ROLL.EXP ###.TIF」(###には任意のTIFF画像ファイルを指定)と入力。TIFF画像は解像度256*256まで、32768色、非圧縮のものが使えます。
パッドの左右で回転、上下で画像位置を上下移動、RUNボタンで右移動、SELECTで左移動、Aボタンで縮小、Bボタンで拡大、RUN & SELECTボタン同時押しで回転角と表示位置のリセット、ABボタン同時押しで拡大率を1倍に戻す、どれかキーボードのキーを押せば終了となります。

# High Cの最適化テクニック
FM TOWNSの標準開発環境である「High C コンパイラ」は古いコンパイラということもあって、今のコンパイラにあるような高度な最適化を殆どしてくれないといっていい。やったとしても定数化位なものだと思っていいかもしれない。
そこで人力で最適化を行っていく。High Cコンパイラに限らず化石みたいなコンパイラをどうしても触ることになった人にも役に立つTIPSかもしれない。ただし、後述でも何度も言うが現在のコンパイラでは自動的に最適化してくれるのでやっても意味が無く、かえって読みにくいだけのコードになってしまうので絶対に記述しないように。

## for文をdo ~ while化 ##
例えば(for i = 0; i < 256; i++) {
という文はHigh Cだとそのまま
     sub edx, edx

     loop:

     cmp edx, 256

     jl end_loop

     ループ内実行文

     inc edx

     jmp loop

     end_loop:

となんのひねりもなくループの最後に無条件ジャンプで最初に飛んでそこでループから抜けるか判定するというそのままなコンパイルされてしまう。

そこで

     i = 0;
 
     do {
 
     while (i < 256);

と記述すると

     sub edx, edx

     loop:

     ループ内実行文

     inc edx

     cmp edx, 256

     jl loop:

と余分なjmp命令が消えループの最後だけでループを継続するか抜けるか判定されるようになる。

ちなみに、今時のコンパイラはこの程度の最適化は問題がない(ループの最初で確実に抜けない)と判断されれば自動的にやってくれるし、仮にやらなくても分岐予測や投機実行がある今時のCPUではコンパイラが出力してくるコードの方が早いからそのように出てくるだけ。今では無駄知識になっているので必要性が無く昔の最適化TIPSに頼ってdo ~ while化するのは止めておきましょう。

## 2重ループの内側でregister指定子 ##
2重ループしている場合、内側が最適化されればそれだけで高速化するが、変数が多い場合は内側ループ内で使う変数が少なくてもレジスタからでなくメモリ参照となるコードが出力されてしまう。
そこで

     register int temp_a = sum;

     do {
 
         register int temp_b = add;
 
         i = 0;
 
         do {
 
              table[i] = sum;
 
              sum += sum;
 
              i++;
 
          while (i < TABLE_MAX);

とループ手前に記述すればループ内でメモリ操作はtable[]への書き込みだけとなり、カウントのiも含めてすべてレジスタ演算のみで済む可能性が高い。ただし、x86 CPUはレジスタ数が少なくregister指定子をつけられるのは2つまでと思っておいた方がいい。つけすぎるとレジスタ本数が少ないのに無理にレジスタを使うような回りくどいコードが吐き出されかえって低速化する。
 
なお、これまた**今のコンパイラではregister指定子は記述しても無視されるようになっているものが大半**なので記述するのは全く意味がありません。

## 8.8固定小数点の同時演算(SIMD化) ##
このコードでは8.8固定小数点をshort型(16bit)に入れているのだが、その固定小数点形式のX座標・Y座標の計算で別々に加算するのではなく、int型(32bit)に両値を入れておけば一度の加算で済ませてしまうことが可能となる。今でいうSIMD演算だ。short 2つ・int 1つの共用体(union)を作り、そのshort 2つにXYをそれぞれ入れる、intを取り出せば同時にXYが出てくる、int型の代入・演算もどうせ前述のregister指定子の際にint型を指定してしまえばそれだけで済んでしまう。
